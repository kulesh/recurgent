# ADR 0010: Dependency-Aware Generated Programs and Environment Contract v1

- Status: proposed
- Date: 2026-02-14

## Context

Recurgent currently constrains generated code to Ruby stdlib. This keeps runtime behavior simple but blocks common specialist tasks (HTML -> PDF, advanced parsing, rich API clients) and causes avoidable delegation churn when specialists repeatedly hit capability limits.

We want specialists to decide implementation dependencies while keeping Solver language intent-first (`purpose`, `deliverable`, `acceptance`, `failure_policy`). The runtime must then materialize a deterministic execution environment from specialist-declared dependencies.

Two hard constraints shape the design:

1. Ruby cannot unload activated gems in-process.
2. Recurgent `context` and `result` currently support arbitrary Ruby objects.

## Decision

### 1. Provider Output Contract Changes from `code` to `GeneratedProgram`

Provider adapters MUST return a `GeneratedProgram` payload:

```json
{
  "code": "Ruby code string",
  "dependencies": [
    { "name": "prawn", "version": "~> 2.5" }
  ]
}
```

Rules:

1. `code` is required and MUST be non-empty.
2. `dependencies` is optional; default is `[]`.
3. Backward compatibility: if provider returns only a String, runtime interprets it as `{ code: <string>, dependencies: [] }`.

Runtime tool schema MUST be updated accordingly (provider-facing only):

```json
{
  "type": "object",
  "properties": {
    "code": { "type": "string" },
    "dependencies": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "version": { "type": "string" }
        },
        "required": ["name"],
        "additionalProperties": false
      }
    }
  },
  "required": ["code"],
  "additionalProperties": false
}
```

### 2. Dependency Manifest Normalization

Runtime MUST normalize `dependencies[]` before any environment action.

Normalization algorithm:

1. Validate each element is a Hash-like object.
2. `name`:
   - MUST match `/\A[a-zA-Z0-9_-]+\z/`.
   - Normalize to lowercase.
3. `version`:
   - Optional.
   - Default to `">= 0"`.
4. Reject duplicate gem names with different version constraints in the same payload (`invalid_dependency_manifest`).
5. Sort by `[name, version]`.
6. Freeze normalized manifest for deterministic hashing and logging.

### 3. Environment Contract v1

Environment contract v1 is specialist-scoped and immutable after first successful execution.

Definitions:

1. `specialist_instance_id`: unique id for each `Agent` instance.
2. `env_manifest`: normalized dependency manifest attached to specialist instance.
3. `env_id`: `sha256("ruby:#{RUBY_VERSION}|deps:#{normalized_manifest_json}")`.

Rules:

1. On first successful dynamic call for a specialist:
   - runtime sets `env_manifest` from `GeneratedProgram.dependencies`.
   - runtime resolves and materializes environment for `env_id`.
2. On subsequent calls for same specialist:
   - if dependencies are empty, runtime reuses stored `env_manifest`.
   - if dependencies normalize to exactly same `env_manifest`, runtime reuses environment.
   - otherwise runtime returns `dependency_manifest_changed` error outcome (non-retriable for current specialist instance).
3. To change dependencies, Solver MUST delegate a new specialist instance.

This immutability avoids context migration and cross-call environment drift.

### 4. Environment Materialization

For each new `env_id`, runtime MUST create:

`$XDG_CACHE_HOME/recurgent/ruby-envs/<env_id>/`

Contents:

1. `Gemfile` (generated)
2. `Gemfile.lock` (resolved)
3. `vendor/bundle/` (installed gems)

Generated `Gemfile` template:

```ruby
source "https://rubygems.org"

# generated by Recurgent
gem "prawn", "~> 2.5"
```

Materialization steps:

1. Write Gemfile atomically.
2. Run `bundle lock` in env directory.
3. Run `bundle install --path vendor/bundle --jobs 4 --retry 2`.
4. Mark environment ready by writing `.ready` metadata file containing manifest and lock checksum.

If any step fails, runtime returns typed dependency error outcome.

### 5. Execution Model (Ruby v1): Dedicated Worker per Specialist Environment

Runtime MUST execute generated code in a dedicated Ruby worker process bound to specialist `env_id`.

Why:

1. Gem activation isolation.
2. No global gem pollution across specialists.
3. Stable per-specialist context lifecycle.

Worker lifecycle:

1. Spawn worker once specialist `env_id` is known.
2. Boot with:
   - `BUNDLE_GEMFILE=<env_dir>/Gemfile`
   - `BUNDLE_PATH=<env_dir>/vendor/bundle`
   - `require "bundler/setup"`
3. Worker owns specialist `context` in-memory.
4. Main process sends execution requests to worker; worker returns result/error envelopes.

Transport:

1. Internal length-prefixed Marshal frames over stdin/stdout.
2. Request payload fields:
   - `call_id`, `method_name`, `code`, `args`, `kwargs`
3. Response payload fields:
   - `status`, `value` OR `error_class`/`error_message`.

### 6. Outcome Mapping Extensions

Add error types:

1. `invalid_dependency_manifest`
2. `dependency_resolution_failed`
3. `dependency_install_failed`
4. `dependency_activation_failed`
5. `dependency_manifest_changed`

`retriable` rules:

1. `dependency_resolution_failed` -> `false`
2. `dependency_install_failed` -> `true`
3. `dependency_activation_failed` -> `true`
4. `dependency_manifest_changed` -> `false`
5. `invalid_dependency_manifest` -> `false`

Outcome error metadata MUST include:

1. `specialist_role`
2. `method_name`
3. `env_id` (if known)
4. `dependency_name` (if applicable)

### 7. Observability Requirements

Each call log entry MUST include:

1. `program_dependencies` (raw from provider payload)
2. `normalized_dependencies`
3. `env_id`
4. `environment_cache_hit` (boolean)
5. `env_prepare_ms`
6. `worker_pid`

### 8. Implementation Plan (Ruby Runtime)

#### 8.1 New Files

1. `runtimes/ruby/lib/recurgent/generated_program.rb`
2. `runtimes/ruby/lib/recurgent/dependency_manifest.rb`
3. `runtimes/ruby/lib/recurgent/environment_manager.rb`
4. `runtimes/ruby/lib/recurgent/worker_executor.rb`

#### 8.2 File Changes

1. `runtimes/ruby/lib/recurgent/providers.rb`
   - Replace `generate_code` with `generate_program`.
2. `runtimes/ruby/lib/recurgent/runtime_helpers.rb`
   - Update provider tool schema to include `dependencies`.
   - Add prompt instructions requiring non-stdlib dependencies be declared in payload.
3. `runtimes/ruby/lib/recurgent.rb`
   - Parse `GeneratedProgram`.
   - Resolve/freeze specialist environment on first call.
   - Route execution through `WorkerExecutor`.
   - Extend `_error_outcome_for` and logging fields.
4. `runtimes/ruby/lib/recurgent/outcome.rb`
   - No structural change required.

#### 8.3 Test Additions

1. `spec/dependency_manifest_spec.rb`
   - validation/normalization/conflict cases.
2. `spec/environment_manager_spec.rb`
   - deterministic `env_id`, cache hit, install failure mapping.
3. `spec/worker_executor_spec.rb`
   - context persistence across calls, execution error mapping.
4. Extend `spec/recurgent_spec.rb`
   - `GeneratedProgram` backward compatibility.
   - `dependency_manifest_changed` behavior.
5. Acceptance scenario:
   - specialist declares dependency and succeeds on second call with cache hit.

## Consequences

### Positive

1. Specialists can use the Ruby gem ecosystem without polluting Solver-level language.
2. Environment behavior becomes deterministic and observable.
3. Capability failures become explicit and machine-actionable.

### Tradeoffs

1. Runtime complexity increases (environment manager + workers).
2. First-call latency increases for new dependency sets.
3. Specialists cannot mutate dependency manifest after first success; they must re-delegate.

## Rejected Alternatives

1. Solver-provided gem lists in `delegate(...)`.
   - Rejected: leaks implementation details into Solver intent language.

2. In-process dynamic gem activation without isolation.
   - Rejected: global gem pollution and non-deterministic cross-specialist behavior.

3. Allowing dependency manifest to change mid-specialist-session.
   - Rejected: requires unsafe context migration and breaks reproducibility.
