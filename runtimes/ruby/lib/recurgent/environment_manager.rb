# frozen_string_literal: true

require "digest"
require "fileutils"
require "json"
require "open3"
require "rbconfig"

class Agent
  class EnvironmentManager
    READY_FILENAME = ".ready.json"

    def initialize(gem_sources:, source_mode:, cache_root: nil, command_runner: nil)
      @gem_sources = Array(gem_sources).map(&:to_s).map(&:strip).reject(&:empty?).uniq
      @source_mode = source_mode.to_s
      @policy_sources = @gem_sources.sort
      @cache_root = cache_root || self.class.default_cache_root
      @command_runner = command_runner || method(:_default_command_runner)
    end

    def self.default_cache_root
      cache_home = ENV.fetch("XDG_CACHE_HOME", File.join(Dir.home, ".cache"))
      File.join(cache_home, "recurgent", "ruby-envs")
    end

    def env_id_for(manifest)
      serialized_manifest = JSON.generate(manifest)
      serialized_sources = JSON.generate(@policy_sources)
      payload = [
        "engine:#{RUBY_ENGINE}",
        "ruby:#{RUBY_VERSION}",
        "patchlevel:#{RUBY_PATCHLEVEL}",
        "platform:#{RUBY_PLATFORM}",
        "source_mode:#{@source_mode}",
        "sources:#{serialized_sources}",
        "deps:#{serialized_manifest}"
      ].join("|")
      Digest::SHA256.hexdigest(payload)
    end

    def ensure_environment!(manifest)
      started_at = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      env_id = env_id_for(manifest)
      env_dir = File.join(@cache_root, env_id)
      FileUtils.mkdir_p(env_dir)
      _write_gemfile(env_dir, manifest)

      if _cache_hit?(env_dir, manifest)
        return _build_result(
          env_id: env_id,
          env_dir: env_dir,
          cache_hit: true,
          prepare_ms: _elapsed_ms(started_at),
          resolve_ms: 0.0,
          install_ms: 0.0
        )
      end

      resolve_ms = _measure_ms { _run_bundle_lock(env_dir) }
      install_ms = _measure_ms { _run_bundle_install(env_dir) }
      _write_ready_metadata(env_dir, manifest)

      _build_result(
        env_id: env_id,
        env_dir: env_dir,
        cache_hit: false,
        prepare_ms: _elapsed_ms(started_at),
        resolve_ms: resolve_ms,
        install_ms: install_ms
      )
    end

    private

    def _build_result(env_id:, env_dir:, cache_hit:, prepare_ms:, resolve_ms:, install_ms:)
      {
        env_id: env_id,
        env_dir: env_dir,
        environment_cache_hit: cache_hit,
        env_prepare_ms: prepare_ms,
        env_resolve_ms: resolve_ms,
        env_install_ms: install_ms
      }
    end

    def _cache_hit?(env_dir, manifest)
      ready_metadata = _read_ready_metadata(env_dir)
      return false unless ready_metadata

      ready_metadata["manifest"] == _serialized_manifest(manifest) &&
        ready_metadata["source_mode"] == @source_mode &&
        ready_metadata["gem_sources"] == @policy_sources &&
        ready_metadata["lock_checksum"] == _lock_checksum(env_dir)
    end

    def _write_gemfile(env_dir, manifest)
      gemfile_path = File.join(env_dir, "Gemfile")
      content = _build_gemfile(manifest)
      temp_path = "#{gemfile_path}.tmp"
      File.write(temp_path, content)
      FileUtils.mv(temp_path, gemfile_path)
    ensure
      FileUtils.rm_f(temp_path) if defined?(temp_path)
    end

    def _build_gemfile(manifest)
      lines = @gem_sources.map { |source| %(source "#{source}") }
      lines << ""
      lines << "# generated by Recurgent"
      manifest.each do |dependency|
        lines << %(gem "#{dependency[:name]}", "#{dependency[:version]}")
      end
      "#{lines.join("\n")}\n"
    end

    def _run_bundle_lock(env_dir)
      _run_bundle_command(env_dir, ["lock"], Agent::DependencyResolutionError, "bundle lock")
    end

    def _run_bundle_install(env_dir)
      _run_bundle_command(
        env_dir,
        ["install", "--path", "vendor/bundle", "--jobs", "4", "--retry", "2"],
        Agent::DependencyInstallError,
        "bundle install"
      )
    end

    def _run_bundle_command(env_dir, args, error_class, label)
      command = [RbConfig.ruby, "-S", "bundle", *args]
      stdout, stderr, status = @command_runner.call(command, env_dir: env_dir)
      return if status.success?

      message = stderr.to_s.strip
      message = stdout.to_s.strip if message.empty?
      message = "unknown failure" if message.empty?
      raise error_class, "#{label} failed in #{env_dir}: #{message}"
    end

    def _default_command_runner(command, env_dir:)
      Open3.capture3(*command, chdir: env_dir)
    end

    def _write_ready_metadata(env_dir, manifest)
      payload = {
        manifest: _serialized_manifest(manifest),
        lock_checksum: _lock_checksum(env_dir),
        source_mode: @source_mode,
        gem_sources: @policy_sources,
        prepared_at: Time.now.utc.strftime("%Y-%m-%dT%H:%M:%S.%3NZ")
      }
      File.write(File.join(env_dir, READY_FILENAME), JSON.generate(payload))
    end

    def _read_ready_metadata(env_dir)
      ready_path = File.join(env_dir, READY_FILENAME)
      return nil unless File.exist?(ready_path)

      JSON.parse(File.read(ready_path))
    rescue JSON::ParserError
      nil
    end

    def _lock_checksum(env_dir)
      lock_path = File.join(env_dir, "Gemfile.lock")
      return nil unless File.exist?(lock_path)

      Digest::SHA256.hexdigest(File.read(lock_path))
    end

    def _elapsed_ms(started_at)
      _round_ms((Process.clock_gettime(Process::CLOCK_MONOTONIC) - started_at) * 1000)
    end

    def _measure_ms
      started_at = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      yield
      _elapsed_ms(started_at)
    end

    def _round_ms(value)
      value.round(1)
    end

    # Normalize symbol keys to strings for stable cache comparison.
    def _serialized_manifest(manifest)
      manifest.map { |dep| dep.transform_keys(&:to_s) }
    end
  end
end
